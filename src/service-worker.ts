// Ref: https://github.com/microsoft/TypeScript/issues/11781
/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="es2020" />
/// <reference lib="webworker" />
declare let self: ServiceWorkerGlobalScope

import { build, files, version } from '$service-worker'

const APP_CACHE = `app-cache-${version}`
const OFFLINE_URL = '/offline.html'

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const toCache = [...build, ...files]
const staticAssets = new Set(toCache)

self.addEventListener('install', (event) => {
	event.waitUntil(
		caches
			.open(APP_CACHE)
			.then((cache) => cache.addAll(toCache))
			.then(() => {
				self.skipWaiting()
			})
	)
})

self.addEventListener('activate', (event) => {
	event.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== APP_CACHE) await caches.delete(key)
			}

			self.clients.claim()
		})
	)
})

self.addEventListener('fetch', (event) => {
	if (event.request.method !== 'GET' || event.request.headers.has('range'))
		return

	const url = new URL(event.request.url)

	// don't try to handle e.g. data: URIs
	const isHttp = url.protocol.startsWith('http')
	const isDevServerRequest =
		url.hostname === self.location.hostname && url.port !== self.location.port
	const isStaticAsset =
		url.host === self.location.host && staticAssets.has(url.pathname)
	const skipBecauseUncached =
		event.request.cache === 'only-if-cached' && !isStaticAsset

	if (!isHttp || isDevServerRequest || skipBecauseUncached) return

	if (isStaticAsset) {
		event.respondWith(
			(async () => {
				const cached = await caches.match(event.request)
				if (cached) return cached

				const response = await fetch(event.request)
				const cache = await caches.open(APP_CACHE)
				cache.put(event.request, response.clone())
				return response
			})()
		)
		return
	}

	if (event.request.mode === 'navigate') {
		event.respondWith(
			(async () => {
				try {
					return await fetch(event.request)
				} catch {
					return (await caches.match(OFFLINE_URL)) ?? Response.error()
				}
			})()
		)
		return
	}

	event.respondWith(fetch(event.request))
})
